/***************************************************************
 ILWIS integrates image, vector and thematic data in one unique 
 and powerful package on the desktop. ILWIS delivers a wide 
 range of feautures including import/export, digitizing, editing, 
 analysis and display of data as well as production of 
 quality mapsinformation about the sensor mounting platform
 
 Exclusive rights of use by 52°North Initiative for Geospatial 
 Open Source Software GmbH 2007, Germany

 Copyright (C) 2007 by 52°North Initiative for Geospatial
 Open Source Software GmbH

 Author: Jan Hendrikse, Willem Nieuwenhuis,Wim Koolhoven 
 Bas Restsios, Martin Schouwenburg, Lichun Wang, Jelle Wind 

 Contact: Martin Schouwenburg; schouwenburg@itc.nl; 
 tel +31-534874371

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 2 as published by the Free Software Foundation.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program (see gnu-gpl v2.txt); if not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA or visit the web page of the Free
 Software Foundation, http://www.fsf.org.

 Created on: 2007-02-8
 ***************************************************************/
/*
  export .IMG format
  by Willem Nieuwenhuis, februari 2000
  ILWIS Department ITC
*/
#include "Headers\toolspch.h"
#include "Engine\Map\Raster\Map.h"
#include "Engine\DataExchange\Convloc.h"
#include "Headers\Hs\CONV.hs"         // for the strings"
#include "Engine\Domain\dmsort.h"
#include "Engine\Domain\dmident.h"
#include "Engine\Domain\Dmvalue.h"
#include "Engine\Domain\dmpict.h"
#include "Engine\DataExchange\expidaimg.h"

/*
   fnObject   : the name of the ilwis map
   fnFile     : the name of the .BMP file
   The ExportIDA function has its prototype in the CONVLOC.H file
*/
void ImpExp::ExportIDA(const FileName& fnObject, const FileName& fnFile)
{
  try {
    (IDAExporter(fnObject, fnFile)).Export(trq);
  }
  catch (AbortedByUser& ) {  // just stop, no message
  }
  catch (ErrorObject& err) {
    err.Show();
  }
}

/* ----------------- IDAExporter ------------------- */
IDAExporter::IDAExporter(const FileName& _fnIn, const FileName& _fnOut) :
    fnIn(_fnIn),
    fnOut(_fnOut),
    outFile(NULL)
{
}

IDAExporter::~IDAExporter()
{
  if (outFile) 
    delete outFile;
}

void IDAExporter::Export(Tranquilizer& trq)
{
  trq.SetTitle(TR("Export to IDA format"));  // the title in the report window
  trq.SetText(TR("Processing..."));   // the text in the report window
  
  inMap = Map(fnIn);

  FileName fnOutPut = FileName::fnUnique(FileName(String("%S.img",fnOut.sFullPath(false))));
  outFile = new File(fnOutPut, facCRT);
  outFile->SetErase(true);  // remove the file in case of errors.

  // write data
  if (inMap->dm()->pdi())         // Image map
      ExportImagePixels(trq);
  else if (inMap->dm()->pdbool()) // Bool map
      ExportBoolPixels(trq);
  else if (inMap->dm()->pdbit())  // Bit map
      ExportBitPixels(trq);
  else if (inMap->dm()->pdc() || inMap->dm()->pdid())   // ID or Class map
      ExportSortPixels(trq);
  else if (inMap->dm()->pdv())    // other value maps
      ExportValuePixels(trq);

  else if (inMap->dm()->pdp())    // Picture map
      throw ErrorImportExport(TR("Color and Picture maps cannot be exported to IDA format"));
  else if (inMap->dm()->pdcol())  // Color map
			throw ErrorImportExport(TR("Color and Picture maps cannot be exported to IDA format"));

  outFile->SetErase(false);  // no problems occurred: keep the IMG file
}

void IDAExporter::WriteHeader()
{
	memset(&idaHeader, 0, sizeof(idaHeader));
  idaHeader.width     = inMap->iCols();
  idaHeader.height    = inMap->iLines();
	String sTitle("Generated by ILWIS");
	memcpy(idaHeader.title, sTitle.c_str(), sTitle.length());

  outFile->Write(sizeof(idaHeader), &idaHeader);
}

void IDAExporter::ExportImagePixels(Tranquilizer& trq)
{
	WriteHeader();
    
	// transfer the image data
	WriteAsRaw(trq);
}    

void IDAExporter::ExportBoolPixels(Tranquilizer& trq)
{
  WriteHeader();
    
	// transfer the image data
	WriteAsRaw(trq);
}    

void IDAExporter::ExportBitPixels(Tranquilizer& trq)
{
    WriteHeader();

	// transfer the image data
	WriteAsRaw(trq);
}    

void IDAExporter::ExportValuePixels(Tranquilizer& trq)
{
    Domain dm = inMap->dm();
    DomainValue* pdv = dm->pdv();
    if (pdv == NULL)
      return;    // impossible to come here

    Representation rpr = dm->rpr();
    double rStep = inMap->vr()->rStep();
    RangeReal rrMinMax = pdv->rrMinMax();

    if (rStep >= 1) 
		{
      bool fPossible = (rrMinMax.rLo() >= 0 && rrMinMax.rHi() <= 255);
      if (fPossible) 
			{
			  WriteHeader();
    
        WriteAsByteValues(trq);
        return;
      }
    }
		else
			throw ErrorImportExport(TR("Values are not in 0 to 255 range"));
    return;
}

// export class/ID map
void IDAExporter::ExportSortPixels(Tranquilizer& trq)
{
    DomainSort* pds = inMap->dm()->pdsrt();
    if (pds->iNettoSize() > 255) {
      TooManyClassesForExport(outFile->sName());
    }
    else 
		{
      WriteHeader();
      WriteAsRaw(trq);
    }
}    

void IDAExporter::WriteAsRaw(Tranquilizer& trq)
{
  ByteBuf buf(inMap->iCols());
  byte b[4] = {0, 0, 0, 0};
  
  for (long iRow = 0; iRow < inMap->iLines(); ++iRow)
  {
    inMap->GetLineRaw(iRow, buf);
    if ( trq.fUpdate(iRow, inMap->iLines())) 
      return;
    outFile->Write(inMap->iCols(), buf.buf());
  }
}

void IDAExporter::WriteAsByteValues(Tranquilizer& trq)
{
  LongBuf bufIn(inMap->iCols());
  ByteBuf bufOut(inMap->iCols());
  byte b[4] = {0, 0, 0, 0};
    
  for (long iRow = 0; iRow < inMap->iLines(); ++iRow)
  {
    inMap->GetLineVal(iRow, bufIn);
    if ( trq.fUpdate(iRow, inMap->iLines())) 
      return;
    for (long iCol = 0; iCol < inMap->iCols(); iCol++) {
      long iVal = bufIn[iCol];
      if (iVal == iUNDEF)
        bufOut[iCol] = 0;
      else
        bufOut[iCol] = bufIn[iCol];   // values do fit, their range lies between 0 and 255
    }

    outFile->Write(inMap->iCols(), bufOut.buf());
  }
}
