/***************************************************************
 ILWIS integrates image, vector and thematic data in one unique 
 and powerful package on the desktop. ILWIS delivers a wide 
 range of feautures including import/export, digitizing, editing, 
 analysis and display of data as well as production of 
 quality mapsinformation about the sensor mounting platform
 
 Exclusive rights of use by 52°North Initiative for Geospatial 
 Open Source Software GmbH 2007, Germany

 Copyright (C) 2007 by 52°North Initiative for Geospatial
 Open Source Software GmbH

 Author: Jan Hendrikse, Willem Nieuwenhuis,Wim Koolhoven 
 Bas Restsios, Martin Schouwenburg, Lichun Wang, Jelle Wind 

 Contact: Martin Schouwenburg; schouwenburg@itc.nl; 
 tel +31-534874371

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 2 as published by the Free Software Foundation.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program (see gnu-gpl v2.txt); if not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA or visit the web page of the Free
 Software Foundation, http://www.fsf.org.

 Created on: 2007-02-8
 ***************************************************************/
/*-----------------------------------------------
   $Log: /ILWIS 3.0/ForeignFormat/PolygonMapIlwis20.cpp $
 * 
 * 6     29/11/00 9:21 Willem
 * Adjusted and reduced the number of interface function necessary.
 * The correct virtual functions in PolygonMapIlwis20 are now called from
 * SegmentMapIlwis20
 * 
 * 5     16/11/00 12:43 Willem
 * Added virtual Store() functions that store the data
 * 
 * 4     14/08/00 14:59 Willem
 * Some code cleanup.
 * 
 * 3     19/04/00 17:32 Willem
 * Added warning message when Ilwis 3 has more polygons than Ilwis 2 can
 * handle
 * 
 * 2     19/04/00 16:57 Willem
 * Removed unnecessary include files
 * 
 * 1     19/04/00 16:48 Willem
 * Added polygon map export to Ilwis version 2

   PolygonMapIlwis20.cpp
   by Willem Nieuwenhuis, 4/17/00
   ILWIS Department ITC
  -----------------------------------------------*/

#pragma warning( disable : 4786 )

#include "Headers\toolspch.h"

#pragma warning( disable : 4715 )

#include <set>
#include "Headers\toolspch.h"
#include "Engine\Base\File\Directory.h"
#include "Headers\Hs\CONV.hs"
#include "Headers\Hs\polygon.hs"
#include "Engine\Base\DataObjects\ilwisobj.h"
#include "Engine\Domain\dmsort.h"
#include "Engine\Base\File\COPIER.H"
#include "Engine\Applications\objvirt.h"
#include "Engine\Applications\ApplicationMap.h"
#include "Engine\Base\System\Engine.h"
#include "Engine\DataExchange\ForeignFormat.h"
#include "Engine\Map\Polygon\POL14.H"
#include "Engine\DataExchange\PolygonMapIlwis20.h"
#include "Engine\Base\File\BaseCopier.h"
#include "Engine\Base\File\ObjectCopier.h"

PolygonMapIlwis20::PolygonMapIlwis20()
{
}

PolygonMapIlwis20::PolygonMapIlwis20(const FileName& fnForgn, ForeignFormat::mtMapType _mtType)
	: SegmentMapIlwis20(fnForgn, _mtType)
{
	m_sTitle = SPOLTitleExport20Polygons;
}

PolygonMapIlwis20::~PolygonMapIlwis20()
{
}

void PolygonMapIlwis20::LoadTable(TablePtr* tbl)
{
}

void PolygonMapIlwis20::WriteODF(IlwisObject obj)
{
	SegmentMapIlwis20::WriteODF(obj);

	PolygonMap& polmap = static_cast<PolygonMap&>(obj);

	String s;
	s = String("PolygonMap %S, generated by ILWIS 3", fnGetForeignFile().sFile);
	ObjectInfo::WriteElement("Ilwis", "Description",   fnGetForeignFile(), s);

	ObjectInfo::WriteElement("BaseMap", "Type",        fnGetForeignFile(), "PolygonMap");
	ObjectInfo::WriteElement("PolygonMap", "Type",     fnGetForeignFile(), "PolygonMapStore");

	String sDataFile = FileName(m_filPolygons->sName()).sRelative(true, fnGetForeignFile().sPath());
	ObjectInfo::WriteElement("PolygonMapStore", "DataPol",     fnGetForeignFile(), sDataFile);
	sDataFile = FileName(m_filCodes->sName()).sRelative(true, fnGetForeignFile().sPath());
	ObjectInfo::WriteElement("PolygonMapStore", "DataPolCode", fnGetForeignFile(), sDataFile);
	sDataFile = FileName(m_filTopology->sName()).sRelative(true, fnGetForeignFile().sPath());
	ObjectInfo::WriteElement("PolygonMapStore", "DataTop",     fnGetForeignFile(), sDataFile);
	ObjectInfo::WriteElement("PolygonMapStore", "Polygons",    fnGetForeignFile(), polmap->iPol());
}

void PolygonMapIlwis20::CreateFiles()
{
	m_filSegments = new File(FileName(fnGetForeignFile(), ".ps#"), facCRT);
	m_filCodes = new File(FileName(fnGetForeignFile(), ".pc#"), facCRT);
	m_filCoords = new File(FileName(fnGetForeignFile(), ".pd#"), facCRT);

	m_filPolygons = new File(FileName(fnGetForeignFile(), ".pl#"), facCRT);
	m_filTopology = new File(FileName(fnGetForeignFile(), ".tp#"), facCRT);

	m_filSegments->SetErase(true);
	m_filCodes->SetErase(true);
	m_filCoords->SetErase(true);
	m_filPolygons->SetErase(true);
	m_filTopology->SetErase(true);
}

void PolygonMapIlwis20::CloseFiles()
{
	m_filSegments->SetErase(false);
	m_filCodes->SetErase(false);
	m_filCoords->SetErase(false);
	m_filPolygons->SetErase(false);
	m_filTopology->SetErase(false);

	if (m_filSegments) delete m_filSegments;
	if (m_filCodes) delete m_filCodes;
	if (m_filCoords) delete m_filCoords;
	if (m_filPolygons) delete m_filPolygons;
	if (m_filTopology) delete m_filTopology;
}

void PolygonMapIlwis20::WriteData(IlwisObject obj)
{
	polmap = static_cast<PolygonMap&>(obj);

	toptype tt;
	ZeroMemory(&tt, sizeof(toptype));
	tt.iFwd = (short)polmap->iPol();                    // first topology stores #polygons
	m_filTopology->Write(sizeof(toptype), &tt);  // make room for first topology

	SegmentMapIlwis20::WriteSegData(polmap->smp());
	WritePolMapData();
}

void PolygonMapIlwis20::Store(IlwisObject obj)
{
	PolygonMap& polmap = static_cast<PolygonMap&>(obj);
	SegmentMap segmap = polmap->smp();

	SegmentMapIlwis20::Store(obj);
}

void PolygonMapIlwis20::WriteTopologyLinks(const Segment& seg)
{
	Topology top(polmap, seg.iCurr());

	toptype tt;
	tt.iBwd = top.Bwl();
	tt.iFwd = top.Fwl();
	long iPol = top.LeftPol();
	tt.iPolLeft  = iPol == iUNDEF ? -1 : iPol;
	iPol = top.RightPol();
	tt.iPolRight = iPol == iUNDEF ? -1 : iPol;

	m_filTopology->Write(sizeof(toptype), &tt);
}

void PolygonMapIlwis20::GetCoordinates(const Segment& seg, long& iCrd, CoordBuf& cbuf)
{
	Topology top(polmap, seg.iCurr());
	bool fIsFwd = top.fForward();

	seg.GetCoords(iCrd, cbuf);
}

void PolygonMapIlwis20::WritePolMapData()
{
	poltype pt;
	String sPolVal;
	trq.SetText(SPOLTextStoringPolygonNames);

	DomainSort *pdsrt = m_dmMap->pdsrt();
	bool fCodes = (0 != pdsrt) && pdsrt->fCodesAvailable();

	m_iNrPols = 0;

	long iNrTotPol = polmap->iPol();
	long iPolRaw;
	double rPolVal;
	ilwPolygon pol;
	for (pol = polmap->polFirst(); pol.fValid(); ++pol)
	{
		if (m_iNrPols > 32000)
		{
			String sWarn = String(SPOLErrTooManyPolygons_I.scVal(), m_iNrPols);
			getEngine()->Message(sWarn.scVal(),
								SPOLTitleExport20Polygons.scVal(),
								MB_OK | MB_ICONEXCLAMATION);
			break;
		}

		if (trq.fUpdate(m_iNrPols, iNrTotPol))
			return;

		if (m_dmMap->fRawAvailable())
		{
			rPolVal = rUNDEF;
			iPolRaw = pol.iRaw();

			if (0 == pdsrt)
				sPolVal = pol.sValue();
			else 
			{
				if (fCodes)
					sPolVal = pdsrt->sCodeByRaw(iPolRaw);
				else
					sPolVal = pdsrt->sNameByRaw(iPolRaw);

			}
		}
		else
		{
			iPolRaw = iUNDEF;
			rPolVal = pol.rValue();
		}

		sPolVal = sPolVal.sLeft(15);     // maximum length of polygon names
		sPolVal = sPolVal.sTrimSpaces();
		ZeroMemory(&pt, sizeof(poltype));
		for (unsigned int ii = 0; ii < sPolVal.length(); ii++)
			if (sPolVal[ii] == ' ')
				sPolVal[ii] = '_';
		pt.sName = sPolVal;

		CoordBounds cb = pol.cbBounds();
		MinMax mmBounds;
		mmBounds.rcMin.Col = (long)((cb.cMin.x - m_rBeta1) / m_rAlfa);
		mmBounds.rcMin.Row = (long)((cb.cMin.y - m_rBeta2) / m_rAlfa);
		mmBounds.rcMax.Col = (long)((cb.cMax.x - m_rBeta1) / m_rAlfa);
		mmBounds.rcMax.Row = (long)((cb.cMax.y - m_rBeta2) / m_rAlfa);
		pt.mm = mmBounds;
		
		Topology topStart = pol.topStart();
		pt.iSegStart = topStart.fForward() ? topStart.iCurr() : -topStart.iCurr();
		pt.iNrSeg = 0; // unused  in 2.x
		pt.rArea = pol.rArea();
		pt.rLength = (float) pol.rLen();
		m_filPolygons->Write(sizeof(poltype), &pt);

		if (m_dmMap->fRawAvailable())
			m_filCodes->Write(sizeof(long), &iPolRaw);
		else
			m_filCodes->Write(sizeof(double), &rPolVal);
		m_iNrPols++;
	}
}

CoordSystem PolygonMapIlwis20::GetCoordSystem()
{
	return CoordSystem();
}
