/***************************************************************
 ILWIS integrates image, vector and thematic data in one unique 
 and powerful package on the desktop. ILWIS delivers a wide 
 range of feautures including import/export, digitizing, editing, 
 analysis and display of data as well as production of 
 quality mapsinformation about the sensor mounting platform
 
 Exclusive rights of use by 52°North Initiative for Geospatial 
 Open Source Software GmbH 2007, Germany

 Copyright (C) 2007 by 52°North Initiative for Geospatial
 Open Source Software GmbH

 Author: Jan Hendrikse, Willem Nieuwenhuis,Wim Koolhoven 
 Bas Restsios, Martin Schouwenburg, Lichun Wang, Jelle Wind 

 Contact: Martin Schouwenburg; schouwenburg@itc.nl; 
 tel +31-534874371

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 2 as published by the Free Software Foundation.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program (see gnu-gpl v2.txt); if not, write to
 the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 Boston, MA 02111-1307, USA or visit the web page of the Free
 Software Foundation, http://www.fsf.org.

 Created on: 2007-02-8
 ***************************************************************/
/* impbna.c
   Import Segments from Atlas BNA
   by Willem Nieuwenhuis, march 11, 1996
   ILWIS Department ITC
   Last change:  WN   17 Aug 2001
*/
/*
  Revision history:
  15-04-97: When coordinates in the BNA file were preceeded by white space, the coordinate
            detected failed to work correctly. As a result the CoordBounds were invalid.
            When after the scan phase, a Segment Map was created the import crashed. Solved.
*/

#include "Headers\toolspch.h"
#include "Engine\DataExchange\Convloc.h"
#include "Engine\Map\Segment\Seg.h"
#include "Engine\Map\Segment\SEGSTORE.H"
#include "Engine\Map\Polygon\POLSTORE.H"
#include "Engine\Map\Point\PNTSTORE.H"
#include "Engine\Domain\dmsort.h"

#include "Engine\Base\DataObjects\ERR.H"
#include "Engine\Base\DataObjects\Dat2.h"
#include <vector>

enum kind { KNDClass, KNDID, KNDValue, KNDNone };

class BNAReader;

class BNAEntity
{
	friend class BNAReader;
public:
	enum BNAEntityType {beUNKNOWN, bePOINT, beSEGMENT, bePOLYGON, beCIRCLE, beINVALID}; 

	BNAEntity();
	virtual ~BNAEntity() {}

	void           Clear();  // only clear buffer
	virtual void   Reset();  // reset all

	BNAEntityType  beType();
	CoordBounds    cb();

	String         sName();
	String         sCode();
	String         sID();

	long           iCoordCount();

protected:
	long           m_iPos;
	CoordBounds    m_cbMap;
	CoordBuf       m_cbuf;
	BNAEntityType  m_be;

	String         m_sPrimary;       // Required name of BNA item
	String         m_sSecondary;     // First optional name of BNA item
	String         m_sID;            // Optional unique ID of BNA item
	long           m_iCoordExpected; // the number of coords as indicated in the BNA file

	void           SetCoordExpected(long iNr);
	void           AddCoord(const Coord& crd);
	Coord& operator [](long iIndex);
};

class BNAPoint : public BNAEntity
{
public:
	Coord crdPoint();
};

class BNASegment : public BNAPoint
{
public:
	long iGetCoords(CoordBuf& cbuf);
};

class BNAPolygon : public BNASegment
{
	friend class BNAReader;
public:
	BNAPolygon();
	virtual void   Reset();  // reset all

	long iNrParts();
	long iBeginCoord(long iPart);
	long iEndCoord(long iPart);

private:
	vector<RowCol>  m_vrcIndex;   // list of start,end indices in the coordinates
};

/*--------------------------------------------------*/
/* BNAEntity Implementation                         */
/*--------------------------------------------------*/
BNAEntity::BNAEntity()
{
	m_iPos = 0;
	m_iCoordExpected = 0;
	m_be = beUNKNOWN;
}

BNAEntity::BNAEntityType BNAEntity::beType()
{
	return m_be;
}

// Resize the Coord buffer if it is not large enough
// Copying the contents is not necessary here, because the function is 
// only called at the start of the reading of an entity.
void BNAEntity::SetCoordExpected(long iNr)
{
	// Check if we have a circle or anything else
	// The coordinates for a circle are generated by ILWIS and therefore
	// need to be set explicitly
	if (iNr == 2)
		m_iCoordExpected = 215; // a number slightly above 2*pi/0.03
	else
		m_iCoordExpected = abs(iNr);
	if (m_iCoordExpected > m_cbuf.iSize())
		m_cbuf.Size(m_iCoordExpected);
}

void BNAEntity::Clear()
{
	m_iPos = 0;
}

void BNAEntity::Reset()
{
	m_iPos = 0;
	m_be = BNAEntity::beUNKNOWN;
}

String BNAEntity::sName()
{
	return m_sPrimary;
}

String BNAEntity::sCode()
{
	return m_sSecondary;
}

String BNAEntity::sID()
{
	return m_sID;
}

long BNAEntity::iCoordCount()
{
	return m_iPos + 1;
}

CoordBounds BNAEntity::cb()
{
	return m_cbMap;
}

void BNAEntity::AddCoord(const Coord& crd)
{
	// if buffer is not large enough, resize and copy contents
	if (m_iPos >= m_cbuf.iSize())
	{
		CoordBuf cb(m_cbuf.iSize() * 2);
		for (int i = 0; i < m_cbuf.iSize(); i++)
			cb[i] = m_cbuf[i];
		m_cbuf = cb;
	}
	m_cbuf[m_iPos++] = crd;
	m_cbMap += crd;
}

Coord& BNAEntity::operator [](long iIndex)
{
	if (iIndex >= 0 && iIndex < m_iPos)
		return m_cbuf[iIndex];

	throw ErrorImportExport(SCVErrCoordIndexOutOfBounds); // very, very unlikely to happen!!!
}

/*--------------------------------------------------*/
/* BNAPoint Implementation                          */
/*--------------------------------------------------*/
Coord BNAPoint::crdPoint()
{
	if (m_iPos == 1)
		return m_cbuf[0];
	else
		return Coord();
}

/*--------------------------------------------------*/
/* BNASegment Implementation                        */
/*--------------------------------------------------*/
long BNASegment::iGetCoords(CoordBuf& cbuf)
{
	cbuf = m_cbuf;
	return m_iPos;
}

/*--------------------------------------------------*/
/* BNAPolygon Implementation                        */
/*--------------------------------------------------*/
BNAPolygon::BNAPolygon()
{
}

void BNAPolygon::Reset()
{
	BNAEntity::Reset();
	m_vrcIndex.clear();
}

long BNAPolygon::iNrParts()
{
	return m_vrcIndex.size();
}

long BNAPolygon::iBeginCoord(long iPart)
{
	if (iPart >= 0 && iPart < m_vrcIndex.size())
		return m_vrcIndex[iPart].Row;
	else
		return iUNDEF;
}

long BNAPolygon::iEndCoord(long iPart)
{
	if (iPart >= 0 && iPart < m_vrcIndex.size())
		return m_vrcIndex[iPart].Col;
	else
		return iUNDEF;
}

/*--------------------------------------------------*/
class BNAReader
{
public:
	BNAReader(const FileName& fnInput, Tranquilizer& trq);
	~BNAReader();

	bool  fEof();
	void  Read(BNAEntity& bna);

private:
	File          *m_file;
	long          m_iLine, m_iTotLines;
	Tranquilizer  &m_trq;

	void          ReadLine(String&);
	void          GetEntityInfo(BNAEntity& bna);
	Coord         crdRead();
	long          iReadPolygonPart(BNAEntity& bna, long iPos, Coord& crdOuter = Coord());
	double        rReadRadius();

	void          ReadPoint(BNAEntity&);
	void          ReadSegment(BNAEntity&);
	void          ReadCircle(BNAEntity&);
	void          ReadPolygon(BNAEntity&, long iPos);

	String        sUnquote(const String&);
};

BNAReader::BNAReader(const FileName& fnInput, Tranquilizer& trq)
	: m_trq(trq)
{
	m_iLine = 0;
	m_iTotLines = 0;
	m_file = 0;
	if (File::fExist(fnInput))
		m_file = new File(fnInput);
	else
		throw ErrorNotFound(fnInput);
}

BNAReader::~BNAReader()
{
	if (m_file)
		delete m_file;
}

bool BNAReader::fEof()
{
	return m_file->fEof();
}

void BNAReader::ReadLine(String& sLine)
{
	m_file->ReadLnAscii(sLine);
	m_iLine++;

	if (m_iLine % 10 == 0)
		if (m_trq.fUpdate(m_file->iLoc() / 1000, m_file->iSize() / 1000))
			UserAbort(m_file->sName());
}

void BNAReader::Read(BNAEntity& bna)
{
	bna.Reset();

	GetEntityInfo(bna);

	switch (bna.beType())
	{
		case BNAEntity::bePOINT:
			ReadPoint(bna);
			break;
		case BNAEntity::beCIRCLE:
			ReadCircle(bna);
			break;
		case BNAEntity::beSEGMENT:
			ReadSegment(bna);
			break;
		case BNAEntity::bePOLYGON:
			ReadPolygon(bna, 0);
			break;
	}
}

String BNAReader::sUnquote(const String& sQuoted)
{
	long iFirstQuote = sQuoted.find_first_of("\"");
	long iLastQuote  = sQuoted.find_last_of("\"");

	if (iFirstQuote == string::npos)
		iFirstQuote = -1;
	if (iLastQuote == string::npos)
		iLastQuote = sQuoted.length();

	return sQuoted.substr(iFirstQuote + 1, iLastQuote - iFirstQuote - 1);
}

//   Read the line containing segment/polygon name
//   General format of BNA:
//     "name","code","ID",type/length        ; also allowed without quotes
//   or
//     name<tab>code<tab>ID<tab>type/length  ; quotes are NOT allowed
//   name is required, code and ID are optional
//
//   Type/length field (|number| indicate #coordinates):
//      <= -2   : segment
//      =   1   : point
//      =   2   : circle
//      >=  4   : polygon
void BNAReader::GetEntityInfo(BNAEntity& bna)
{
	String sLine;
	ReadLine(sLine);
	if (sLine.sTrimSpaces().length() == 0 && m_file->fEof())
	{
		bna.m_be = BNAEntity::beUNKNOWN;
		return;
	}

	Array<String> as;
	Split(sLine, as, ",\t");
	int iSize = as.iSize();
	if (iSize < 2 || iSize > 4)
	{
		String sErr = SCVErrIllegalBNA;
		sErr &= String(SCVTextInLine_l.scVal(), m_iLine);
		throw ErrorImportExport(sErr);
	}

	// Determine the type of the feature
	long iValType;
	iValType = as[iSize - 1].iVal();     // return the type/length

	bna.SetCoordExpected(iValType);
	if (iValType <= -2)
		bna.m_be = BNAEntity::beSEGMENT;
	else if (abs(iValType) == 1)
		bna.m_be = BNAEntity::bePOINT;
	else if (iValType == 2)
		bna.m_be = BNAEntity::beCIRCLE;
	else if (iValType >= 4)
		bna.m_be = BNAEntity::bePOLYGON;
	else
	{
		String sErr = SCVErrIllegalBNA;
		sErr &= String(SCVTextInLine_l.scVal(), m_iLine);
		throw ErrorImportExport(sErr);
	}

	bna.m_sPrimary = sUnquote(as[0]);  // required primary name
	if (iSize > 2)
		bna.m_sSecondary = sUnquote(as[1]);
	if (iSize > 3)
		bna.m_sID = sUnquote(as[2]);
}

// Coordinates in Atlas BNA are stored X first Y second, separated by a comma or TAB
// Optionally a CoordSystem code is prefixed. This code is skipped, only the coord 
// is extracted.
// Syntax:
//   [CSY code,]<X>,<Y> or
//   [CSY code<TAB>]<X><TAB><Y>
Coord BNAReader::crdRead()
{
	String sLine;
	ReadLine(sLine);
	Array<String> as;
	Split(sLine, as, ",\t");
	if (as.iSize() != 2 && as.iSize() != 3)
	{
		String sErr = SCVErrCoordinateExpected;
		sErr &= String(SCVTextInLine_l.scVal(), m_iLine);
		throw ErrorImportExport(sErr);
	}

	int iFirst = as.iSize() == 3 ? 1 : 0;

	Coord cFile;
	cFile.x = as[iFirst].rVal();
	cFile.y = as[iFirst + 1].rVal();
	if (cFile.x == rUNDEF || cFile.y == rUNDEF)
	{
		String sErr = SCVErrCoordinateExpected;
		sErr &= String(SCVTextInLine_l.scVal(), m_iLine);
		throw ErrorImportExport(sErr);
	}

	return cFile;
}

// Radius line for circle definition should be:
//    radius, 0
// ILWIS will accept the absence of the zero
double BNAReader::rReadRadius()
{
	String sLine;
	ReadLine(sLine);
	Array<String> as;
	Split(sLine, as, ",\t");
	if (as.iSize() != 1 && as.iSize() != 2)
	{
		String sErr = SCVErrCircleRadiusExpected;
		sErr &= String(SCVTextInLine_l.scVal(), m_iLine);
		throw ErrorImportExport(sErr);
	}

	double rRadius = as[0].rVal();
	if (rRadius == rUNDEF)
	{
		String sErr = SCVErrNumberExpected;
		sErr &= String(SCVTextInLine_l.scVal(), m_iLine);
		throw ErrorImportExport(sErr);
	}

	return rRadius;
}

void BNAReader::ReadPoint(BNAEntity& bna)
{
	bna.AddCoord(crdRead());
}

void BNAReader::ReadSegment(BNAEntity& bna)
{
	int i = 0;
	while (i < bna.m_iCoordExpected)
	{
		bna.AddCoord(crdRead());
		++i;
	}
}

void BNAReader::ReadCircle(BNAEntity& bna)
{
	Coord crdCenter = crdRead();
	double rRadius = rReadRadius();

	double rEndAngle = 2 * M_PI;
	double rAngle = 0;
	long iNr = 0;
	while (rAngle <= rEndAngle)
	{
		Coord cNew = Coord(crdCenter.x + rRadius * cos(rAngle),
		                   crdCenter.y + rRadius * sin(rAngle));
		bna.AddCoord(cNew);
		rAngle += 0.03;
		iNr++;
	}
	// The circle has now become a polygon
	bna.m_be = BNAEntity::bePOLYGON;

	// Make sure that internal administration also knows that the polygon exists
	BNAPolygon& bnaPol = dynamic_cast<BNAPolygon&>(bna);
	bnaPol.m_vrcIndex.push_back(RowCol(0L, iNr - 1L));
}

long BNAReader::iReadPolygonPart(BNAEntity& bna, long iPos, Coord& crdOuter)
{
	// If this is the main polygon, then crdOuter != UNDEF, which means
	// the first coordinate needs to be read from file only for islands/lakes
	// This first coordinate is then remembered to be able to detect the
	// end point of the polygon part.
	Coord crdFirst;
	if (crdOuter.fUndef())
		crdFirst = crdRead();
	else
		crdFirst = crdOuter;

	Coord crd = crdFirst;
	long i = iPos;
	do
	{
		bna.AddCoord(crd);
		crd = crdRead();
		i++;
	}
	while (crd != crdFirst);
	bna.AddCoord(crd);  // also add closing coordinate

	BNAPolygon& bnaPol = dynamic_cast<BNAPolygon&>(bna);
	bnaPol.m_vrcIndex.push_back(RowCol(iPos, i));

	return i;
}

void BNAReader::ReadPolygon(BNAEntity& bna, long iPos)
{
	// Read the first coordinate; in case of islands/lakes this is needed to
	// check the end of the islands/lakes
	Coord crdFirst = crdRead();

	// Read the main polygon, upto and including the closing coordinate (crdFirst);
	long i = iReadPolygonPart(bna, iPos, crdFirst);

	// Check if end of polygon reached; if not then lakes/islands follow
	// If there are no islands/lakes then i == bna->m_iCoordExpected - 1, all coords are read
	// If there are islands/lakes then:
	//  1. i <  bna->m_iCoordExpected - 2: more islands/lakes follow
	//  2. i == bna->m_iCoordExpected - 2, islands/lakes done: the main polygon closing coord will follow.
	while (i < bna.m_iCoordExpected - 2)
	{
		// Read an island/lake upto and including its closing coordinate
		i = iReadPolygonPart(bna, i + 1);

		// Also read the closing coordinate of the main polygon
		i++;
		Coord crd = crdRead();
		bna.AddCoord(crd);
		if (crdFirst != crd)
		{
			String sErr = SCVErrClosingCoordMissing;
			sErr &= String(SCVTextInLine_l.scVal(), m_iLine);
			throw ErrorImportExport(sErr);
		}
	}
	while (i <= bna.m_iCoordExpected - 2) // allow for empty island/hole sections at end
	{
		i++;
		if (crdFirst != crdRead())
		{
			String sErr = SCVErrClosingCoordMissing;
			sErr &= String(SCVTextInLine_l.scVal(), m_iLine);
			throw ErrorImportExport(sErr);
		}
	}
}

/*--------------------------------------------------*/
class ObjectWriter
{
public:
	ObjectWriter(const FileName& fnBase);

	void Write(BNAEntity& bna);
	void WriteAttributes(long iRec, BNAEntity& bna, Table& tblAttr);
	void AcceptResult(bool fAccept);

private:
	void WritePoint(BNAEntity&);
	void WriteSegment(BNAEntity&);
	void WritePolygon(BNAEntity&);

	FileName   m_fnBase;
	PointMap   m_mpp;
	SegmentMap m_mps;
	PolygonMap m_mpa;

	Table      m_mppAttr;
	Table      m_mpsAttr;
	Table      m_mpaAttr;
};

ObjectWriter::ObjectWriter(const FileName& fnBase)
	: m_fnBase(fnBase)
{
}

void ObjectWriter::WriteAttributes(long iRec, BNAEntity& bna, Table& tblAttr)
{
	tblAttr->iRecNew();
	Column col = tblAttr->col("Name");
	col->PutVal(iRec, bna.sName());
	if (bna.sCode().length() > 0)
	{
		Column col = tblAttr->col("Secondary");
		if (!col.fValid())
			col = Column(tblAttr, "Secondary", Domain("String"));
		col->PutVal(iRec, bna.sCode());
	}
	if (bna.sID().length() > 0)
	{
		Column col = tblAttr->col("ID");
		if (!col.fValid())
			col = Column(tblAttr, "ID", Domain("String"));
		col->PutVal(iRec, bna.sID());
	}
}

void ObjectWriter::Write(BNAEntity& bna)
{
	switch (bna.beType())
	{
		case BNAEntity::bePOINT:
			WritePoint(bna);
			break;
		case BNAEntity::beSEGMENT:
			WriteSegment(bna);
			break;
		case BNAEntity::bePOLYGON:
			WritePolygon(bna);
			break;
	}
}

void ObjectWriter::AcceptResult(bool fAccept)
{
	if (m_mpp.fValid()) m_mpp->fErase = !fAccept;
	if (m_mps.fValid()) m_mps->fErase = !fAccept;
	if (m_mpa.fValid()) m_mpa->fErase = !fAccept;

	if (m_mppAttr.fValid()) m_mppAttr->fErase = !fAccept;
	if (m_mpsAttr.fValid()) m_mpsAttr->fErase = !fAccept;
	if (m_mpaAttr.fValid()) m_mpaAttr->fErase = !fAccept;
}

void ObjectWriter::WritePoint(BNAEntity& bna)
{
	if (!m_mpp.fValid())
	{
		FileName fnPnt = FileName(m_fnBase, ".mpp");
		Domain dom(fnPnt, 0, dmtUNIQUEID, "Pnt");
		m_mpp = PointMap(fnPnt, CoordSystem(), CoordBounds(), dom);
		m_mpp->fErase = true;

		FileName fnAtt(String("%S_pnt", fnPnt.sFile), ".tbt", true);
		fnAtt.Dir(fnPnt.sPath());
		m_mppAttr = Table(fnAtt, dom);
		m_mppAttr->fErase = true;
		Column col = Column(m_mppAttr, "Name", Domain("String"));
		m_mpp->SetAttributeTable(m_mppAttr);
	}

	BNAPoint& bnaPnt = dynamic_cast<BNAPoint&>(bna);
	long iNew = m_mpp->iFeatures() + 1;
	m_mpp->fChanged = true;
	ILWIS::Point *pnt = CPOINT(m_mpp->newFeature());
	pnt->setCoord(bnaPnt.crdPoint());
	pnt->PutVal(iNew);
	DomainSort *pds = m_mpp->dm()->pdsrt();
	pds->Resize(iNew);

	WriteAttributes(iNew, bna, m_mppAttr);
}

void ObjectWriter::WriteSegment(BNAEntity& bna)
{
	if (!m_mps.fValid())
	{
		FileName fnSeg = FileName(m_fnBase, ".mps");
		Domain dom(fnSeg, 0, dmtUNIQUEID, "Seg");
		m_mps = SegmentMap(fnSeg, CoordSystem(), CoordBounds(), dom);
		m_mps->fErase = true;

		FileName fnAtt(String("%S_seg", fnSeg.sFile), ".tbt", true);
		fnAtt.Dir(fnSeg.sPath());  // make sure to use the correct path
		m_mpsAttr = Table(fnAtt, dom);
		m_mpsAttr->fErase = true;
		Column col = Column(m_mpsAttr, "Name", Domain("String"));
		m_mps->SetAttributeTable(m_mpsAttr);
	}

	BNASegment& bnaSeg = dynamic_cast<BNASegment&>(bna);

	ILWIS::Segment *seg = CSEGMENT(m_mps->newFeature());
	CoordBuf cbuf;
	long iNrCoords = bnaSeg.iGetCoords(cbuf);
	seg->PutCoords(iNrCoords, cbuf);
	seg->PutVal(m_mps->iFeatures());

	CoordBounds cb = m_mps->cb();
	cb += seg->cbBounds();
	m_mps->SetCoordBounds(cb);

	DomainSort *pds = m_mps->dm()->pdsrt();
	pds->Resize(m_mps->iFeatures());

	m_mpsAttr->iRecNew();

	WriteAttributes(m_mps->iFeatures(), bnaSeg, m_mpsAttr);
	Column colLength = m_mpsAttr->col("Length");
	if ( !colLength.fValid())
		colLength = m_mpsAttr->colNew("Length",DomainValueRangeStruct(-1e307, 1e307, 0.001));	
	colLength->PutVal(m_mps->iFeatures(), seg->rLength());
}

void ObjectWriter::WritePolygon(BNAEntity& bna)
{
	if (!m_mpa.fValid())
	{
		FileName fnPol = FileName(m_fnBase, ".mpa");
		Domain dom(fnPol, 0, dmtUNIQUEID, "Pol");
		m_mpa = PolygonMap(fnPol, CoordSystem(), CoordBounds(), dom);
		m_mpa->fErase = true;

		FileName fnAtt(String("%S_pol", fnPol.sFile), ".tbt", true);
		fnAtt.Dir(fnPol.sPath());
		m_mpaAttr = Table(fnAtt, dom);
		m_mpaAttr->fErase = true;
		Column col = Column(m_mpaAttr, "Name", Domain("String"));
		m_mpa->SetAttributeTable(m_mpaAttr);
	}

	BNAPolygon& bnaPol = dynamic_cast<BNAPolygon&>(bna);

	CoordBuf cbuf;
	ILWIS::Polygon *pol;
	long iNrCoords = bnaPol.iGetCoords(cbuf);
	long iNew;
	CoordBounds cbPol = m_mpa->cb();

	CoordBuf cbufPol;
	for (int iPart = 0; iPart < bnaPol.iNrParts(); iPart++)
	{
		long iStart = bnaPol.iBeginCoord(iPart);
		long iEnd = bnaPol.iEndCoord(iPart);
		iNrCoords = iEnd - iStart + 1;
		cbufPol.Size(iNrCoords);
		vector<Coordinate> *coords = new vector<Coordinate>();
		for (int iCrd = iStart; iCrd <= iEnd; iCrd++)
			coords->push_back(cbuf[iCrd]);

		CoordinateSequence *seq = new CoordinateArraySequence(coords);
		LinearRing *ring = new LinearRing(seq, new GeometryFactory());
		iNew = m_mpa->iFeatures() + 1;
		DomainSort *pds = m_mpa->dm()->pdsrt();
		pds->Resize(iNew);

		pol = CPOLYGON(m_mpa->newFeature());
		pol->addBoundary(ring);
		pol->PutVal(iNew);
		//pol = m_mpa->polNewIsland(String("%li", iNew), iNrCoords, cbufPol);
		cbPol += pol->cbBounds();
		m_mpa->SetCoordBounds(cbPol);

		m_mpaAttr->iRecNew();

		WriteAttributes(iNew, bnaPol, m_mpaAttr);
	}
}

/*--------------------------------------------------*/
class BNAConvertor
{
public:
	BNAConvertor() {}

	void DoTheWork(const FileName& fnBNA, const FileName& fnBase);

};

void BNAConvertor::DoTheWork(const FileName& fnBNA, const FileName& fnBase)
{
	Tranquilizer trq;
	trq.SetTitle(SCVTitleImportBNA);
	trq.SetText(SCVTextProcessing);
	trq.fUpdate(0);
	BNAReader    reader(fnBNA, trq);
	ObjectWriter writer(fnBase);

	BNAPolygon   item;  // the entity is reused (for all types!)
	while (!reader.fEof())
	{
		reader.Read(item);
		writer.Write(item);
	}
	writer.AcceptResult(true);  // keep output files when no errors occur
}

/*--------------------------------------------------*/
void ImpExp::ImportBNA(const FileName& fnFile, const FileName& fnObject )
{
	BNAConvertor bcv;
	bcv.DoTheWork(fnFile, fnObject);
}
